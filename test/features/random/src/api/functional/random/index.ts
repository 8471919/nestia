/**
 * @packageDocumentation
 * @module api.functional.random
 * @nestia Generated by Nestia - https://github.com/samchon/nestia 
 */
//================================================================
import { Fetcher, HttpError } from "@nestia/fetcher";
import type { IConnection, Primitive } from "@nestia/fetcher";
import typia from "typia";

import type { IPage } from "./../../structures/IPage";
import type { IBbsArticle } from "./../../structures/IBbsArticle";

/**
 * Paginate entire articles.
 * 
 * @param section Section code
 * @param input Page request info
 * @returns Paginated articles with summarized info
 * 
 * @controller RandomController.index()
 * @path PATCH /random/:section
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function index(
    connection: IConnection,
    section: null | string,
    input: index.Input,
): Promise<index.Output> {
    return !!connection.random
        ? index.simulate(
              connection,
              section,
              input,
          )
        : Fetcher.fetch(
              connection,
              index.ENCRYPTED,
              index.METHOD,
              index.path(section),
              input,
          );
}
export namespace index {
    export type Input = Primitive<IPage.IRequest>;
    export type Output = Primitive<IPage<IBbsArticle.ISummary>>;

    export const METHOD = "PATCH" as const;
    export const PATH: string = "/random/:section";
    export const ENCRYPTED: Fetcher.IEncrypted = {
        request: false,
        response: false,
    };

    export const path = (section: null | string): string => {
        return `/random/${encodeURIComponent(section ?? "null")}`;
    }
    export const random = (g?: Partial<typia.IRandomGenerator>): Output =>
        typia.random<Output>(g);
    export const simulate = async (
        connection: IConnection,
        section: null | string,
        input: index.Input,
    ): Promise<Output> => {
        const assert =
            (message: (exp: typia.TypeGuardError) => string) =>
            <T>(task: () => T): void => {
                try {
                    task()
                }
                catch (exp) {
                    if (typia.is<typia.TypeGuardError>(exp))
                        throw new HttpError(
                            METHOD,
                            `${connection.host}${path(section)}`,
                            400,
                            JSON.stringify({
                                method: exp.method,
                                path: exp.path,
                                expected: exp.expected,
                                value: exp.value,
                                message: message(exp),
                            })
                        );
                    throw exp
                }
            };
        assert(
            () => "URL parameter \"section\" is not ${exp.expected} type."
        )(() => typia.assert(section));
        assert(
            () => "Request body is not following the promised type."
        )(() => typia.assert(input));
        return typia.random<Output>(
            typeof connection.random === 'object'
            && connection.random !== null
                ? connection.random
                : undefined
        );
    }
}

/**
 * Paginate entire articles (query ver.).
 * 
 * @param section Section code
 * @param input Page request info
 * @returns Paginated articles with summarized info
 * 
 * @controller RandomController.query()
 * @path GET /random/:section
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function query(
    connection: IConnection,
    section: null | string,
    input: query.Query,
): Promise<query.Output> {
    return !!connection.random
        ? query.simulate(
              connection,
              section,
              input,
          )
        : Fetcher.fetch(
              connection,
              query.ENCRYPTED,
              query.METHOD,
              query.path(section, input),
          );
}
export namespace query {
    export type Query = Primitive<IPage.IRequest>;
    export type Output = Primitive<IPage<IBbsArticle.ISummary>>;

    export const METHOD = "GET" as const;
    export const PATH: string = "/random/:section";
    export const ENCRYPTED: Fetcher.IEncrypted = {
        request: false,
        response: false,
    };

    export const path = (section: null | string, input: query.Query): string => {
        const variables: Record<any, any> = input as any;
        const search: URLSearchParams = new URLSearchParams();
        for (const [key, value] of Object.entries(variables))
            if (value === undefined) continue;
            else if (Array.isArray(value))
                value.forEach((elem) => search.append(key, String(elem)));
            else
                search.set(key, String(value));
        const encoded: string = search.toString();
        return `/random/${encodeURIComponent(section ?? "null")}${encoded.length ? `?${encoded}` : ""}`;;
    }
    export const random = (g?: Partial<typia.IRandomGenerator>): Output =>
        typia.random<Output>(g);
    export const simulate = async (
        connection: IConnection,
        section: null | string,
        input: query.Query,
    ): Promise<Output> => {
        const assert =
            (message: (exp: typia.TypeGuardError) => string) =>
            <T>(task: () => T): void => {
                try {
                    task()
                }
                catch (exp) {
                    if (typia.is<typia.TypeGuardError>(exp))
                        throw new HttpError(
                            METHOD,
                            `${connection.host}${path(section, input)}`,
                            400,
                            JSON.stringify({
                                method: exp.method,
                                path: exp.path,
                                expected: exp.expected,
                                value: exp.value,
                                message: message(exp),
                            })
                        );
                    throw exp
                }
            };
        assert(
            () => "URL parameter \"section\" is not ${exp.expected} type."
        )(() => typia.assert(section));
        assert(
            () => "Request query parameters are not following the promised type."
        )(() => typia.assert(input));
        return typia.random<Output>(
            typeof connection.random === 'object'
            && connection.random !== null
                ? connection.random
                : undefined
        );
    }
}

/**
 * Read an article.
 * 
 * @param section Section code
 * @param id Target article ID
 * @returns Detailed article info
 * 
 * @controller RandomController.at()
 * @path GET /random/:section/:id
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function at(
    connection: IConnection,
    section: string,
    id: string,
): Promise<at.Output> {
    return !!connection.random
        ? at.simulate(
              connection,
              section,
              id,
          )
        : Fetcher.fetch(
              connection,
              at.ENCRYPTED,
              at.METHOD,
              at.path(section, id),
          );
}
export namespace at {
    export type Output = Primitive<IBbsArticle>;

    export const METHOD = "GET" as const;
    export const PATH: string = "/random/:section/:id";
    export const ENCRYPTED: Fetcher.IEncrypted = {
        request: false,
        response: false,
    };

    export const path = (section: string, id: string): string => {
        return `/random/${encodeURIComponent(section ?? "null")}/${encodeURIComponent(id ?? "null")}`;
    }
    export const random = (g?: Partial<typia.IRandomGenerator>): Output =>
        typia.random<Output>(g);
    export const simulate = async (
        connection: IConnection,
        section: string,
        id: string,
    ): Promise<Output> => {
        const assert =
            (message: (exp: typia.TypeGuardError) => string) =>
            <T>(task: () => T): void => {
                try {
                    task()
                }
                catch (exp) {
                    if (typia.is<typia.TypeGuardError>(exp))
                        throw new HttpError(
                            METHOD,
                            `${connection.host}${path(section, id)}`,
                            400,
                            JSON.stringify({
                                method: exp.method,
                                path: exp.path,
                                expected: exp.expected,
                                value: exp.value,
                                message: message(exp),
                            })
                        );
                    throw exp
                }
            };
        assert(
            () => "URL parameter \"section\" is not ${exp.expected} type."
        )(() => typia.assert(section));
        assert(
            () => "URL parameter \"id\" is not ${exp.expected} type."
        )(() => typia.assert(id));
        return typia.random<Output>(
            typeof connection.random === 'object'
            && connection.random !== null
                ? connection.random
                : undefined
        );
    }
}

/**
 * Store a new article.
 * 
 * @param section Section code
 * @param input Content to store
 * @returns Newly archived article
 * 
 * @controller RandomController.store()
 * @path POST /random/:section
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function store(
    connection: IConnection,
    section: string,
    input: store.Input,
): Promise<store.Output> {
    return !!connection.random
        ? store.simulate(
              connection,
              section,
              input,
          )
        : Fetcher.fetch(
              connection,
              store.ENCRYPTED,
              store.METHOD,
              store.path(section),
              input,
          );
}
export namespace store {
    export type Input = Primitive<IBbsArticle.IStore>;
    export type Output = Primitive<IBbsArticle>;

    export const METHOD = "POST" as const;
    export const PATH: string = "/random/:section";
    export const ENCRYPTED: Fetcher.IEncrypted = {
        request: false,
        response: false,
    };

    export const path = (section: string): string => {
        return `/random/${encodeURIComponent(section ?? "null")}`;
    }
    export const random = (g?: Partial<typia.IRandomGenerator>): Output =>
        typia.random<Output>(g);
    export const simulate = async (
        connection: IConnection,
        section: string,
        input: store.Input,
    ): Promise<Output> => {
        const assert =
            (message: (exp: typia.TypeGuardError) => string) =>
            <T>(task: () => T): void => {
                try {
                    task()
                }
                catch (exp) {
                    if (typia.is<typia.TypeGuardError>(exp))
                        throw new HttpError(
                            METHOD,
                            `${connection.host}${path(section)}`,
                            400,
                            JSON.stringify({
                                method: exp.method,
                                path: exp.path,
                                expected: exp.expected,
                                value: exp.value,
                                message: message(exp),
                            })
                        );
                    throw exp
                }
            };
        assert(
            () => "URL parameter \"section\" is not ${exp.expected} type."
        )(() => typia.assert(section));
        assert(
            () => "Request body is not following the promised type."
        )(() => typia.assert(input));
        return typia.random<Output>(
            typeof connection.random === 'object'
            && connection.random !== null
                ? connection.random
                : undefined
        );
    }
}

/**
 * Update an article.
 * 
 * @param section Section code
 * @param id Target article ID
 * @param input Content to update
 * @returns Updated content
 * 
 * @controller RandomController.update()
 * @path PUT /random/:section/:id
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function update(
    connection: IConnection,
    section: string,
    id: string,
    input: update.Input,
): Promise<update.Output> {
    return !!connection.random
        ? update.simulate(
              connection,
              section,
              id,
              input,
          )
        : Fetcher.fetch(
              connection,
              update.ENCRYPTED,
              update.METHOD,
              update.path(section, id),
              input,
          );
}
export namespace update {
    export type Input = Primitive<IBbsArticle.IStore>;
    export type Output = Primitive<IBbsArticle>;

    export const METHOD = "PUT" as const;
    export const PATH: string = "/random/:section/:id";
    export const ENCRYPTED: Fetcher.IEncrypted = {
        request: false,
        response: false,
    };

    export const path = (section: string, id: string): string => {
        return `/random/${encodeURIComponent(section ?? "null")}/${encodeURIComponent(id ?? "null")}`;
    }
    export const random = (g?: Partial<typia.IRandomGenerator>): Output =>
        typia.random<Output>(g);
    export const simulate = async (
        connection: IConnection,
        section: string,
        id: string,
        input: update.Input,
    ): Promise<Output> => {
        const assert =
            (message: (exp: typia.TypeGuardError) => string) =>
            <T>(task: () => T): void => {
                try {
                    task()
                }
                catch (exp) {
                    if (typia.is<typia.TypeGuardError>(exp))
                        throw new HttpError(
                            METHOD,
                            `${connection.host}${path(section, id)}`,
                            400,
                            JSON.stringify({
                                method: exp.method,
                                path: exp.path,
                                expected: exp.expected,
                                value: exp.value,
                                message: message(exp),
                            })
                        );
                    throw exp
                }
            };
        assert(
            () => "URL parameter \"section\" is not ${exp.expected} type."
        )(() => typia.assert(section));
        assert(
            () => "URL parameter \"id\" is not ${exp.expected} type."
        )(() => typia.assert(id));
        assert(
            () => "Request body is not following the promised type."
        )(() => typia.assert(input));
        return typia.random<Output>(
            typeof connection.random === 'object'
            && connection.random !== null
                ? connection.random
                : undefined
        );
    }
}