import { Tabs, Tab } from 'nextra-theme-docs'

## Outline
When developing a test program for NestJS developed backend server, I recommend to adapt E2E test paradigm instead of unit test paradigm. It's because with the [`@nestia/sdk` generated SDK library](../sdk/sdk), E2E test functions can be much easier, safer and efficient for production than the traditional unit test functions.

Furthermore, if you develop test functions utilizing the SDK library, you can easily switch the e2e test functions to the performance benchmark functions. Just by utilizing `@nestia/e2e` library, you can easily measure your NestJS developed backend server's performance through the SDK library utilizing e2e test functions.

![SDK](https://user-images.githubusercontent.com/13158709/215004990-368c589d-7101-404e-b81b-fbc936382f05.gif)

> SDK library utilizing test functions can be used in the performance benchmark program




## Efficient for Production
New era, age of E2E testing paradigm comes.

In the past era, backend developers had developed test programs following the unit test paradigm. It's because traditional E2E test functions' development could not take any advantage of compiled language's type safety. As you can see from the below example code, E2E test functions had to write hard-coded `fetch()` function with string literals.

Besides, unit test could take advantages of compiled language's type safety by importing related modules. Therefore, it was more efficient to develop test functions following the unit test paradigm. This is the reason why unit test paradigm had been loved in the past era.

<Tabs items={[
    "Traditional E2E Test",
    "Traditional Unit Test"
  ]}>
  <Tab>
```typescript showLineNumbers
import { TestValidator } from "@nestia/e2e";
import typia from "typia";

import { IBbsArticle } from "@samchon/bbs-api/lib/structures/bbs/IBbsArticle";

export const test_api_bbs_article_create = async (
  host: string,
): Promise<void> => {
  // In the traditional age, E2E test function could not take advantages 
  // of type safety of the TypeScript. Instead, have to write hard-coded
  // `fetch()` function with string literals.
  const response: Response = await fetch(`${host}/bbs/articles`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      writer: "someone",
      password: "1234",
      title: "title",
      body: "content",
      format: "md",
      files: [],
    } satisfies IBbsArticle.ICreate),
  });
  const article: IBbsArticle = await response.json();
  typia.assert(article);

  const read: IBbsArticle = await (async () => {
    const response: Response = await fetch(`${host}/bbs/articles/${article.id}`);
    const article: IBbsArticle = await response.json();
    return typia.assert(article);
  })();
  TestValidator.equals("written")(article)(read);
};
```
  </Tab>
  <Tab>
```typescript showLineNumbers
import { TestValidator } from "@nestia/e2e";
import typia from "typia";

import { IBbsArticle } from "@samchon/bbs-api/lib/structures/bbs/IBbsArticle";

import { BbsArticleProvider } from "../../../../src/providers/bbs/BbsArticleProvider";

export const test_provider_bbs_article_create = async (): Promise<void> => {
  // Besides, unit test could take advantages of type safety.
  const article: IBbsArticle = await BbsArticleProvider.write({
    writer: "someone",
    password: "1234",
    title: "title",
    body: "content",
    format: "md",
    files: [],
  });
  typia.assert(article);

  // Therefore, unit test had been loved in the past era
  const read: IBbsArticle = await BbsArticleProvider.at(article.id);
  typia.assert(read);
  TestValidator.equals("written")(article)(read);
};
```
  </Tab>
</Tabs>

However, in the new era, e2e test functions also can take advantages of the type safety. Just import SDK library generated by `@nestia/e2e`, and call API funtions of it with TypeScript type hints. In this way, as both e2e test paradigm and unit test paradigm can take advantages of type safety, we have to consider which strategy is suitable for the production environment.

In here article, I recommend to adapt e2e test paradigm in the below reasons.

  - suitable for CDD (Contract Driven Development)
  - easy to develop and maintain
  - much safer than unit testing due to its coverage
  - can be used for the performance benchmark
  - can guide client developers as an example code

Look at the below example code of new era's e2e test function, and compare it with the traditional unit test function. As you can see, e2e test function actually tests the backend server's behavior by calling the real API endpoints of it. Besides, unit test can't test the backend server's actual behavior. It just validates the provider's behavior. This is the reason why new era's e2e test function is safer than unit test function.

Also, such new era's e2e test function can be provided to the client or frontend developers as an example code. It guides them how to call the backend server's API endpoints through the SDK library. In this way, e2e test function can be used as a well-structured document for the client developers.

<Tabs items={[
    "New era's E2E Test",
    "Traditional Unit Test"
  ]}>
  <Tab>
```typescript showLineNumbers
import { TestValidator } from "@nestia/e2e";
import typia from "typia";

import BbsApi from "@samchon/bbs-api";
import { IBbsArticle } from "@samchon/bbs-api/lib/structures/bbs/IBbsArticle";

export const test_provider_bbs_article_create = async (
  connection: BbsApi.IConnection
): Promise<void> => {
  // Unit test functions can't validate 
  // the backend server's actual behavior.
  const article: IBbsArticle = await BbsApi.functional.bbs.articles.create(
    connection,
    {
      writer: "someone",
      password: "1234",
      title: "title",
      body: "content",
      format: "md",
      files: [],
    },
  );
  typia.assert(article);

  // This is the reason why I've adopted the e2e test paradigm
  const read: IBbsArticle = await BbsApi.functional.bbs.articles.at(
    connection,
    article.id,
  );
  typia.assert(read);
  TestValidator.equals("written")(article)(read);
};
```
  </Tab>
  <Tab>
```typescript showLineNumbers
import { TestValidator } from "@nestia/e2e";
import typia from "typia";

import BbsApi from "@samchon/bbs-api";

import { BbsArticleProvider } from "../../../../src/providers/bbs/BbsArticleProvider";

export const test_provider_bbs_article_create = async (): Promise<void> => {
  // Unit test functions can't validate 
  // the backend server's actual behavior.
  const article: IBbsArticle = await BbsArticleProvider.write({
    writer: "someone",
    password: "1234",
    title: "title",
    body: "content",
    format: "md",
    files: [],
  });
  typia.assert(article);

  // This is the reason why I've adopted the e2e test paradigm
  const read: IBbsArticle = await BbsArticleProvider.at(article.id);
  typia.assert(read);
  TestValidator.equals("written")(article)(read);
};
```
  </Tab>
</Tabs>

At last, the new era's e2e test functions can be used for the performance benchmark without any extra dedication. As the e2e test function directly calls the API endpoints of the backend server, backend server performance benchmark program can be easily developed by utilizing them.

Those are the reasons why I recommend to adapt the new era's e2e test paradigm instead of the traditional unit test paradigm. Those are the reason why I am insisting that e2e test functions are efficient for production. From now on, let's see how to compose the e2e test functions for the NestJS developed backend server.

> You can experience benchmark program utilizing e2e test functions.
>
> [https://stackblitz.com/~/github.com/samchon/nestia-start](https://stackblitz.com/~/github.com/samchon/nestia-start?file=docs/benchmarks/AMD%20Ryzen%209%207940HS%20w%20Radeon%20780M%20Graphics.md!,test/benchmark/index.ts&startScript=build:test,benchmark)
>
> [![Benchmark Result Screenshot](/images/benchmark.png)](https://stackblitz.com/~/github.com/samchon/nestia-start?file=docs/benchmarks/AMD%20Ryzen%209%207940HS%20w%20Radeon%20780M%20Graphics.md!,test/benchmark/index.ts&startScript=build:test,benchmark)




## Test Program Development





## Performance Benchmark




