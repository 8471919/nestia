import ts from "typescript";
import { IdentifierFactory } from "typia/lib/factories/IdentifierFactory";

import { IMigrateController } from "../structures/IMigrateController";
import { IMigrateRoute } from "../structures/IMigrateRoute";
import { ISwaggerComponents } from "../structures/ISwaggerComponents";
import { FilePrinter } from "../utils/FilePrinter";
import { ImportProgrammer } from "./ImportProgrammer";
import { SchemaProgrammer } from "./SchemaProgrammer";

export namespace ApiFunctionProgrammer {
  export interface IProps {
    controller: IMigrateController;
    route: IMigrateRoute;
    alias: string;
  }

  export const write =
    (components: ISwaggerComponents) =>
    (importer: ImportProgrammer) =>
    (props: IProps): ts.FunctionDeclaration =>
      FilePrinter.description(
        ts.factory.createFunctionDeclaration(
          [
            ts.factory.createModifier(ts.SyntaxKind.ExportKeyword),
            ts.factory.createModifier(ts.SyntaxKind.AsyncKeyword),
          ],
          undefined,
          props.alias,
          undefined,
          writeParameteers(components)(importer)(props),
          ts.factory.createTypeReferenceNode("Promise", [
            ts.factory.createTypeReferenceNode(
              props.route.success === null ? "void" : `${props.alias}.Output`,
            ),
          ]),
          ts.factory.createBlock(writeBody(importer)(props), true),
        ),
        writeDescription(props),
      );

  const writeDescription = (props: IProps): string =>
    [
      ...(props.route.description?.length
        ? [props.route.description.length, ""]
        : []),
      ...(props.route.deprecated ? ["@deprecated"] : []),
      ...props.route.tags.map((value) => `@tag ${value}`),
      `@controller ${props.controller.name}`,
      `@path ${props.route.path}`,
      "@nestia Generated by Nestia - https://github.com/samchon/nestia",
    ].join("\n");

  const writeParameteers =
    (components: ISwaggerComponents) =>
    (importer: ImportProgrammer) =>
    (props: IProps): ts.ParameterDeclaration[] => [
      IdentifierFactory.parameter(
        "connection",
        ts.factory.createTypeReferenceNode(
          importer.external({
            type: "instance",
            library: "@nestia/Fetcher",
            name: "IConnection",
          }),
          props.route.headers
            ? [ts.factory.createTypeReferenceNode(`${props.alias}.Headers`)]
            : undefined,
        ),
      ),
      ...props.route.parameters.map((p) =>
        IdentifierFactory.parameter(
          p.key,
          SchemaProgrammer.write(components)(importer)(p.schema),
        ),
      ),
      ...(props.route.query
        ? [
            IdentifierFactory.parameter(
              "query",
              ts.factory.createTypeReferenceNode(`${props.alias}.Query`),
            ),
          ]
        : []),
      ...(props.route.body
        ? [
            IdentifierFactory.parameter(
              "input",
              ts.factory.createTypeReferenceNode(`${props.alias}.Input`),
            ),
          ]
        : []),
    ];

  const writeBody =
    (importer: ImportProgrammer) =>
    (props: IProps): ts.Statement[] => {
      const encrypted: boolean = !!props.route.success?.["x-nestia-encrypted"];
      const contentType: string =
        props.route.success?.type ?? "application/json";
      const caller = () =>
        ts.factory.createCallExpression(
          IdentifierFactory.access(
            ts.factory.createIdentifier(
              importer.external({
                type: "instance",
                library: `@nestia/fetcher/lib/${encrypted ? "EncryptedFetcher" : "PlainFetcher"}`,
                name: encrypted ? "EncryptedFetcher" : "PlainFetcher",
              }),
            ),
          )("fetch"),
          undefined,
          [
            contentType
              ? ts.factory.createObjectLiteralExpression(
                  [
                    ts.factory.createSpreadAssignment(
                      ts.factory.createIdentifier("connection"),
                    ),
                    ts.factory.createPropertyAssignment(
                      "headers",
                      ts.factory.createObjectLiteralExpression(
                        [
                          ts.factory.createSpreadAssignment(
                            IdentifierFactory.access(
                              ts.factory.createIdentifier("connection"),
                            )("headers"),
                          ),
                          ts.factory.createPropertyAssignment(
                            ts.factory.createStringLiteral("Content-Type"),
                            ts.factory.createStringLiteral(contentType),
                          ),
                        ],
                        true,
                      ),
                    ),
                  ],
                  true,
                )
              : ts.factory.createIdentifier("connection"),
            ts.factory.createObjectLiteralExpression(
              [
                ts.factory.createSpreadAssignment(
                  IdentifierFactory.access(
                    ts.factory.createIdentifier(props.alias),
                  )("METADATA"),
                ),
                ts.factory.createPropertyAssignment(
                  "path",
                  ts.factory.createCallExpression(
                    IdentifierFactory.access(
                      ts.factory.createIdentifier(props.alias),
                    )("path"),
                    undefined,
                    [
                      ...props.route.parameters.map((p) =>
                        ts.factory.createIdentifier(p.key),
                      ),
                      ...(props.route.query
                        ? [ts.factory.createIdentifier("query")]
                        : []),
                    ],
                  ),
                ),
                ts.factory.createPropertyAssignment(
                  "status",
                  ts.factory.createNull(),
                ),
              ],
              true,
            ),
            ...(props.route.body ? [ts.factory.createIdentifier("input")] : []),
          ],
        );
      return [ts.factory.createReturnStatement(caller())];
    };
}
