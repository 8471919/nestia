import ts from "typescript";
import { ExpressionFactory } from "typia/lib/factories/ExpressionFactory";
import { IdentifierFactory } from "typia/lib/factories/IdentifierFactory";
import { TypeFactory } from "typia/lib/factories/TypeFactory";

import { IMigrateRoute } from "../structures/IMigrateRoute";
import { ISwaggerSchema } from "../structures/ISwaggerSchema";
import { ISwaggerComponents } from "../structures/ISwaggerComponents";
import { FilePrinter } from "../utils/FilePrinter";
import { StringUtil } from "../utils/StringUtil";
import { MigrateImportProgrammer } from "./MigrateImportProgrammer";
import { MigrateSchemaProgrammer } from "./MigrateSchemaProgrammer";

export namespace MigrateNestMethodProgrammer {
  export const write =
    (components: ISwaggerComponents) =>
    (importer: MigrateImportProgrammer) =>
    (route: IMigrateRoute): ts.MethodDeclaration => {
      const output: ts.TypeNode = route.success
        ? MigrateSchemaProgrammer.write(components)(importer)(
            route.success.schema,
          )
        : TypeFactory.keyword("void");

      const method: ts.MethodDeclaration = ts.factory.createMethodDeclaration(
        [
          ...writeMethodDecorators(components)(importer)(route),
          ts.factory.createToken(ts.SyntaxKind.PublicKeyword),
          ts.factory.createToken(ts.SyntaxKind.AsyncKeyword),
        ],
        undefined,
        route.name,
        undefined,
        undefined,
        writeParameters(components)(importer)(route),
        ts.factory.createTypeReferenceNode("Promise", [output]),
        ts.factory.createBlock(
          [
            ...[
              ...route.parameters.map((p) => StringUtil.normalize(p.key)),
              ...(route.headers ? ["headers"] : []),
              ...(route.query ? ["query"] : []),
              ...(route.body ? ["body"] : []),
            ].map((str) =>
              ts.factory.createExpressionStatement(
                ts.factory.createIdentifier(str),
              ),
            ),
            ts.factory.createReturnStatement(
              ts.factory.createCallExpression(
                IdentifierFactory.access(
                  ts.factory.createIdentifier(
                    importer.external({
                      type: "default",
                      library: "typia",
                      name: "typia",
                    }),
                  ),
                )("random"),
                [output],
                undefined,
              ),
            ),
          ],
          true,
        ),
      );
      return FilePrinter.description(method, writeDescription(route));
    };

  const writeDescription = (method: IMigrateRoute): string =>
    [
      ...(method.description?.length ? [method.description.length, ""] : []),
      ...(method.deprecated ? ["@deprecated"] : []),
      ...method.tags.map((value) => `@tag ${value}`),
      "@nestia Generated by Nestia - https://github.com/samchon/nestia",
    ].join("\n");

  const writeMethodDecorators =
    (components: ISwaggerComponents) =>
    (importer: MigrateImportProgrammer) =>
    (route: IMigrateRoute): ts.Decorator[] => {
      const external =
        (lib: string) =>
        (instance: string): ts.Identifier =>
          ts.factory.createIdentifier(
            importer.external({
              type: "instance",
              library: lib,
              name: instance,
            }),
          );
      const router = (instance: string) =>
        ts.factory.createDecorator(
          ts.factory.createCallExpression(
            IdentifierFactory.access(external("@nestia/core")(instance))(
              StringUtil.capitalize(route.method),
            ),
            [],
            [ts.factory.createStringLiteral(route.path)],
          ),
        );

      const decorators: ts.Decorator[] = [];
      if (route.success?.["x-nestia-encrypted"])
        decorators.push(router("EncryptedRoute"));
      else if (route.success?.type === "text/plain")
        decorators.push(
          ts.factory.createDecorator(
            ts.factory.createCallExpression(
              external("@nestjs/common")(StringUtil.capitalize(route.method)),
              [],
              [ts.factory.createStringLiteral(route.path)],
            ),
          ),
        );
      else if (route.success?.type === "application/x-www-form-urlencoded")
        decorators.push(router("TypedQuery"));
      else if (route.success?.type === "application/json")
        decorators.push(router("TypedRoute"));
      else if (route.method === "head")
        decorators.push(
          ts.factory.createDecorator(
            ts.factory.createCallExpression(
              external("@nestjs/common")("Head"),
              [],
              [ts.factory.createStringLiteral(route.path)],
            ),
          ),
        );
      for (const [key, value] of Object.entries(route.exceptions ?? {}))
        decorators.push(
          ts.factory.createDecorator(
            ts.factory.createCallExpression(
              external("@nestia/core")("TypedException"),
              [
                MigrateSchemaProgrammer.write(components)(importer)(
                  value.schema,
                ),
              ],
              [
                isNaN(Number(key))
                  ? ts.factory.createStringLiteral(key)
                  : ExpressionFactory.number(Number(key)),
                ...(value.description?.length
                  ? [ts.factory.createStringLiteral(value.description)]
                  : []),
              ],
            ),
          ),
        );
      return decorators;
    };

  const writeParameters =
    (components: ISwaggerComponents) =>
    (importer: MigrateImportProgrammer) =>
    (route: IMigrateRoute): ts.ParameterDeclaration[] => [
      ...route.parameters.map(({ key, schema: value }) =>
        ts.factory.createParameterDeclaration(
          [
            ts.factory.createDecorator(
              ts.factory.createCallExpression(
                ts.factory.createIdentifier(
                  importer.external({
                    type: "instance",
                    library: "@nestia/core",
                    name: "TypedParam",
                  }),
                ),
                undefined,
                [ts.factory.createStringLiteral(key)],
              ),
            ),
          ],
          undefined,
          StringUtil.normalize(key),
          undefined,
          MigrateSchemaProgrammer.write(components)(importer)(value),
        ),
      ),
      ...(route.headers
        ? [
            writeDtoParameter({ method: "TypedHeaders", variable: "headers" })(
              components,
            )(importer)(route.headers.schema),
          ]
        : []),
      ...(route.query
        ? [
            writeDtoParameter({ method: "TypedQuery", variable: "query" })(
              components,
            )(importer)(route.query.schema),
          ]
        : []),
      ...(route.body
        ? [
            writeDtoParameter({
              method: route.body["x-nestia-encrypted"]
                ? "EncryptedBody"
                : route.body.type === "application/json"
                  ? "TypedBody"
                  : route.body.type === "application/x-www-form-urlencoded"
                    ? ["TypedQuery", "Body"]
                    : route.body.type === "text/plain"
                      ? "PlainBody"
                      : route.body.type === "multipart/form-data"
                        ? ["TypedFormData", "Body"]
                        : "TypedBody",
              variable: "body",
            })(components)(importer)(route.body.schema),
          ]
        : []),
    ];

  const writeDtoParameter =
    (accessor: { method: string | [string, string]; variable: string }) =>
    (components: ISwaggerComponents) =>
    (importer: MigrateImportProgrammer) =>
    (schema: ISwaggerSchema): ts.ParameterDeclaration => {
      const instance = ts.factory.createIdentifier(
        importer.external({
          type: "instance",
          library: "@nestia/core",
          name:
            typeof accessor.method === "string"
              ? accessor.method
              : accessor.method[0],
        }),
      );
      return ts.factory.createParameterDeclaration(
        [
          ts.factory.createDecorator(
            ts.factory.createCallExpression(
              typeof accessor.method === "string"
                ? instance
                : IdentifierFactory.access(instance)(accessor.method[1]),
              undefined,
              undefined,
            ),
          ),
        ],
        undefined,
        StringUtil.normalize(accessor.variable),
        undefined,
        MigrateSchemaProgrammer.write(components)(importer)(schema),
      );
    };
}
